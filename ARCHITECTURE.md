# Architecture

## Components

ccmonitor has two components that communicate through JSON files on disk:

1. **Hook handler** (Go) — Invoked as `ccmonitor hook` by Claude Code hooks on lifecycle events. Reads JSON from stdin, writes a status file per session to `~/.ccmonitor/sessions/<session_id>.json`.

2. **Monitor CLI** (Go) — A long-running process that reads the session files and renders a live-updating terminal display. Read-only — it never writes or deletes session files.

A future GUI would be a third component reading the same session files.

## Data flow

```
Claude Code hooks → Hook handler → Session files ← Monitor CLI
                    (writes)         (JSON on disk)   (reads)
```

## Design decisions

* All hooks are synchronous
* One file per session, latest state only - Each hook event overwrites the session file with the current status. No history is kept. The monitor shows "right now", not what happened before.
* Monitor is read-only - The monitor only reads session files. Hooks are responsible for creating and updating them. This means multiple monitors (CLI, future GUI) can run concurrently without conflicts. Stale session detection (dead PIDs) is displayed visually but the monitor does not delete files.
* PID-based liveness detection - The hook handler captures the Claude Code PID by walking the process tree (our process → shell → Claude Code = grandparent). The monitor checks PID liveness on every refresh via `go-ps`: dead PID → status "exited". This gives immediate detection of crashed sessions without waiting for a timeout.
* Session file cleanup - The `SessionEnd` hook deletes its own session file. Both `SessionStart` and `SessionEnd` scan for session files with dead PIDs and remove them. Additionally, every hook event that writes a session file first removes other files sharing the same PID (`cleanupSamePID`), since a Claude Code process only has one active session at a time. This handles cases where a new session starts without a clean `SessionEnd` for the old one (e.g. `/clear`, `--continue`/`--resume`). No daemon, no cron, no manual cleanup needed.
* last_prompt for task context - The `UserPromptSubmit` hook captures the user's prompt text into a `last_prompt` field. This persists across tool calls until the user sends a new prompt, giving a rough indication of what the session is working on. A future enhancement could replace this with an AI-generated summary.

## Session file schema

```json
{
  "session_id": "abc123",
  "project": "/home/user/myproject",
  "status": "working",
  "detail": "Edit src/main.py",
  "last_prompt": "Write a book about Go programming",
  "notification_type": null,
  "last_activity": "2026-02-02T14:30:00Z",
  "terminals": [
    {"backend": "wt", "id": "42,17436612,4,279"},
    {"backend": "tmux", "id": "%3"}
  ],
  "summary": "Go programming book",
  "pid": 12345
}
```

### Field reference

| Field               | Source                                      | Description                                                                                         |
|---------------------|---------------------------------------------|-----------------------------------------------------------------------------------------------------|
| `session_id`        | Hook stdin `.session_id`                    | Unique ID for the Claude Code session. Used as the filename (`<session_id>.json`).                   |
| `project`           | Hook stdin `.cwd`                           | Absolute path to the project directory the session is running in. Used to group sessions in the UI.  |
| `status`            | Derived from hook event (see mapping below) | Current session state: `starting`, `working`, `idle`, `waiting`, `ended`.                            |
| `detail`            | Derived from hook event + tool info         | Short description of current activity (e.g. `"Edit main.go"`, `"Bash: npm test"`). See hook handler. |
| `last_prompt`       | Hook stdin `.prompt` on `UserPromptSubmit`  | The user's most recent prompt text. Persists across tool calls until a new prompt is sent.            |
| `notification_type` | Hook stdin `.notification_type`             | Set on `Notification` events (`idle_prompt`, `permission_prompt`). Null otherwise.                   |
| `last_activity`     | Generated by hook handler                   | RFC 3339 UTC timestamp of the last hook event. Used for relative time display.                        |
| `terminals`         | Detected terminal backends                  | Array of `{backend, id}` objects (see below). Omitted when empty.                                    |
| `summary`           | Tmux pane title or WT tab name              | Tab/pane title set by Claude Code (with `✳ ` prefix stripped). From tmux `display-message` or WT UI Automation. Tmux preferred when both available. |
| `pid`               | Grandparent PID via process tree walk       | Claude Code's PID, captured by walking up from hook process. Used for liveness checking. Omitted if 0.|

### `terminals` array

The `terminals` field is an array because a session can be running inside multiple nested terminal backends at the same time — most commonly tmux inside Windows Terminal. When that happens, the session has entries for both:

```json
"terminals": [
  {"backend": "wt", "id": "42,17436612,4,279"},
  {"backend": "tmux", "id": "%3"}
]
```

**Order matters.** The hook handler adds WT first, then tmux. The switcher iterates in order — switching the outer WT tab before the inner tmux pane. Each entry has:

- `backend` — Backend name (`"wt"` for Windows Terminal, `"tmux"` for tmux). Matches the value returned by `terminal.Backend.Name()`.
- `id` — Backend-specific identifier. For tmux this is the pane ID (e.g. `%3`). For WT this is the UI Automation RuntimeId (e.g. `42,17436612,4,279`).

Using an array instead of separate fields means adding a new backend (e.g. Zellij, screen) requires no schema changes — just append another entry.

## Status model

```
starting → working ⇄ idle
               ↓
           waiting (needs input/permission)
               ↓
           working (after user responds)
               ↓
             ended
```

- **starting** — Session just began, no activity yet
- **working** — Model is thinking, calling tools, or processing results
- **idle** — Model finished responding, waiting for user's next prompt
- **waiting** — Model needs user attention (permission dialog, idle prompt)
- **ended** — Session terminated normally
- **exited** — Process died without a clean SessionEnd (detected by PID check)

## Hook → Status mapping

| Hook Event         | Status    | Detail                                     |
|--------------------|-----------|--------------------------------------------|
| SessionStart       | starting  | "Session started"                          |
| UserPromptSubmit   | working   | "Processing prompt..." + captures last_prompt |
| PreToolUse         | working   | tool name + summary (e.g. "Edit src/x.py") |
| PostToolUse        | working   | "Finished {tool}, continuing..."           |
| Notification       | waiting   | notification_type                          |
| Stop               | idle      | "Finished responding"                      |
| SessionEnd         | ended     | "Session ended"                            |

## Tab/pane switching

The monitor supports click-to-switch for both tmux panes and Windows Terminal tabs. When a session has both (tmux running inside WT), it switches the WT tab first, then the tmux pane.

**Tmux**: The `$TMUX_PANE` env var is captured on every hook event. Switching runs `tmux select-pane -t <pane>`.

**Windows Terminal**: On `SessionStart`, the hook handler runs a PowerShell script that uses UI Automation to find the currently selected tab in the foreground WT window and stores its RuntimeId (a stable integer array like `42,17436612,4,279`) and tab name. On subsequent events, `wtTabTitle()` looks up the tab by its stored RuntimeId and reads the current name, so the `summary` field stays up to date as Claude Code updates the tab title. The RuntimeId is preserved across hook events by reading it back from the existing session file. Switching runs a similar PowerShell script that searches all WT windows for the tab matching the RuntimeId and selects it.

Detection priority (via env vars): `$TMUX_PANE` and `$WT_SESSION` are checked independently, so both can be captured when tmux runs inside WT.

## Plugin distribution

ccmonitor is packaged as a Claude Code plugin for clean hook registration across platforms.

```
plugin/
├── .claude-plugin/
│   └── plugin.json        # Plugin manifest (name, version, description)
└── hooks/
    └── hooks.json         # Hook registrations for all 7 lifecycle events
```

Hooks call `ccmonitor hook` directly — no shell wrapper scripts, no bash dependency. This works on Windows, Linux, and macOS as long as the `ccmonitor` binary is on PATH.

**Install**: `/plugin marketplace add ./plugin` then `/plugin install ccmonitor`
**Uninstall**: `/plugin uninstall ccmonitor`

The plugin only registers hooks. The `ccmonitor` binary must be installed separately (via `go install`, GitHub releases, or a package manager).

## Tech stack

- **Hook handler**: Go — compiled into the same `ccmonitor` binary, invoked as `ccmonitor hook`
- **Monitor CLI**: Go — compiles to a single binary, no runtime dependency for users
- **Plugin**: Claude Code plugin format — declarative hook registration, no shell scripts
- **Future GUI**: TBD — reads the same session files, independent of the CLI
