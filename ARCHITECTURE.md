# Architecture

## Components

ccmonitor has two components that communicate through JSON files on disk:

1. **Hook handler** (Go) — Invoked as `ccmonitor hook` by Claude Code hooks on lifecycle events. Reads JSON from stdin, writes a status file per session to `~/.ccmonitor/sessions/<session_id>.json`.

2. **Monitor CLI** (Go) — A long-running process that reads the session files and renders a live-updating terminal display. Read-only — it never writes or deletes session files.

A future GUI would be a third component reading the same session files.

## Data flow

```
Claude Code hooks → Hook handler → Session files ← Monitor CLI
                    (writes)         (JSON on disk)   (reads)
```

## Design decisions

* All hooks are synchronous
* One file per session, latest state only - Each hook event overwrites the session file with the current status. No history is kept. The monitor shows "right now", not what happened before.
* Monitor is read-only - The monitor only reads session files. Hooks are responsible for creating and updating them. This means multiple monitors (CLI, future GUI) can run concurrently without conflicts. Stale session detection (dead PIDs) is displayed visually but the monitor does not delete files.
* Session file cleanup - The `SessionEnd` hook deletes its own session file. It also scans for other stale session files (dead PIDs) and removes them. `SessionStart` does the same scan on startup. This means stale files from crashes get cleaned up the next time any session starts or ends — no daemon, no cron, no manual cleanup needed.
* last_prompt for task context - The `UserPromptSubmit` hook captures the user's prompt text into a `last_prompt` field. This persists across tool calls until the user sends a new prompt, giving a rough indication of what the session is working on. A future enhancement could replace this with an AI-generated summary.

## Session file schema

```json
{
  "session_id": "abc123",
  "project": "/home/user/myproject",
  "status": "working",
  "detail": "Edit src/main.py",
  "last_prompt": "Write a book about Go programming",
  "notification_type": null,
  "last_activity": "2026-02-02T14:30:00Z",
  "tmux_pane": "%3",
  "summary": "Go programming book",
  "wt_tab_id": "42,17436612,4,279"
}
```

### Field reference

| Field               | Source                                      | Description                                                                                         |
|---------------------|---------------------------------------------|-----------------------------------------------------------------------------------------------------|
| `session_id`        | Hook stdin `.session_id`                    | Unique ID for the Claude Code session. Used as the filename (`<session_id>.json`).                   |
| `project`           | Hook stdin `.cwd`                           | Absolute path to the project directory the session is running in. Used to group sessions in the UI.  |
| `status`            | Derived from hook event (see mapping below) | Current session state: `starting`, `working`, `idle`, `waiting`, `ended`.                            |
| `detail`            | Derived from hook event + tool info         | Short description of current activity (e.g. `"Edit main.go"`, `"Bash: npm test"`). See hook handler. |
| `last_prompt`       | Hook stdin `.prompt` on `UserPromptSubmit`  | The user's most recent prompt text. Persists across tool calls until a new prompt is sent.            |
| `notification_type` | Hook stdin `.notification_type`             | Set on `Notification` events (`idle_prompt`, `permission_prompt`). Null otherwise.                   |
| `last_activity`     | Generated by hook handler (`date -u`)       | RFC 3339 UTC timestamp of the last hook event. Used for relative time display and stale detection.   |
| `tmux_pane`         | `$TMUX_PANE` environment variable           | Tmux pane ID (e.g. `%3`). Empty when not running in tmux. Used by the monitor for click-to-switch.   |
| `summary`           | Tmux pane title (`tmux display-message`)    | The pane title set by Claude Code (with `✳ ` prefix stripped). Empty outside tmux.                   |
| `wt_tab_id`         | UI Automation RuntimeId on `SessionStart`   | Windows Terminal tab RuntimeId (e.g. `"42,17436612,4,279"`). Omitted when not in WT.                 |

## Status model

```
starting → working ⇄ idle
               ↓
           waiting (needs input/permission)
               ↓
           working (after user responds)
               ↓
             ended
```

- **starting** — Session just began, no activity yet
- **working** — Model is thinking, calling tools, or processing results
- **idle** — Model finished responding, waiting for user's next prompt
- **waiting** — Model needs user attention (permission dialog, idle prompt)
- **ended** — Session terminated normally
- **exited** — Process died without a clean SessionEnd (detected by PID check)

## Hook → Status mapping

| Hook Event         | Status    | Detail                                     |
|--------------------|-----------|--------------------------------------------|
| SessionStart       | starting  | "Session started"                          |
| UserPromptSubmit   | working   | "Processing prompt..." + captures last_prompt |
| PreToolUse         | working   | tool name + summary (e.g. "Edit src/x.py") |
| PostToolUse        | working   | "Finished {tool}, continuing..."           |
| Notification       | waiting   | notification_type                          |
| Stop               | idle      | "Finished responding"                      |
| SessionEnd         | ended     | "Session ended"                            |

## Tab/pane switching

The monitor supports click-to-switch for both tmux panes and Windows Terminal tabs. When a session has both (tmux running inside WT), it switches the WT tab first, then the tmux pane.

**Tmux**: The `$TMUX_PANE` env var is captured on every hook event. Switching runs `tmux select-pane -t <pane>`.

**Windows Terminal**: On `SessionStart`, the hook handler runs a PowerShell script that uses UI Automation to find the currently selected tab in the foreground WT window and stores its RuntimeId (a stable integer array like `42,17436612,4,279`). This only runs once per session — the RuntimeId is preserved across subsequent hook events by reading it back from the existing session file. Switching runs a similar PowerShell script that searches all WT windows for the tab matching the RuntimeId and selects it.

Detection priority (via env vars): `$TMUX_PANE` and `$WT_SESSION` are checked independently, so both can be captured when tmux runs inside WT.

## Plugin distribution

ccmonitor is packaged as a Claude Code plugin for clean hook registration across platforms.

```
plugin/
├── .claude-plugin/
│   └── plugin.json        # Plugin manifest (name, version, description)
└── hooks/
    └── hooks.json         # Hook registrations for all 7 lifecycle events
```

Hooks call `ccmonitor hook` directly — no shell wrapper scripts, no bash dependency. This works on Windows, Linux, and macOS as long as the `ccmonitor` binary is on PATH.

**Install**: `/plugin marketplace add ./plugin` then `/plugin install ccmonitor`
**Uninstall**: `/plugin uninstall ccmonitor`

The plugin only registers hooks. The `ccmonitor` binary must be installed separately (via `go install`, GitHub releases, or a package manager).

## Tech stack

- **Hook handler**: Go — compiled into the same `ccmonitor` binary, invoked as `ccmonitor hook`
- **Monitor CLI**: Go — compiles to a single binary, no runtime dependency for users
- **Plugin**: Claude Code plugin format — declarative hook registration, no shell scripts
- **Future GUI**: TBD — reads the same session files, independent of the CLI
